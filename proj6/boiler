#!/bin/sh

#
# Author: Kelvin Abrokwa-Johnson
# Runs beetle and stuff
#

echo $$


num=""
min=""
max=""
step=""
plotfile=""
statefile=""
cookie="#cookiecookiecookie"


#
# utility functions
#
cleanup() {
    rm -f $statefile
    echo
}


#
# handle signals
#
on_sigint() {
    # clean up and exit
    cleanup
    exit
}

on_sigusr1() {
    # output current size
    echo "current size: $size"
}

on_sigusr2() {
    # save state and exit
    echo "#num=$num"           >> $statefile
    echo "#min=$size"          >> $statefile
    echo "#max=$max"           >> $statefile
    echo "#step=$step"         >> $statefile
    echo "#plotfile=$plotfile" >> $statefile
    exit
}

trap "on_sigint" SIGINT
trap "on_sigusr1" SIGUSR1
trap "on_sigusr2" SIGUSR2


#
# parse command line args
#
while [[ $# -gt 0 ]]; do
    case $1 in
        -n)
            shift; num=$1
            ;;
        -i)
            shift; min=$1
            shift; max=$1
            shift; step=$1
            ;;
        -p)
            shift; plotfile=$1
            ;;
        -r)
            shift; statefile=$1
            ;;
        *)
            echo "unknown argument: $1"
            exit 1
            ;;
    esac
    shift
done


#
# parse recovery flag
#
if [[ -n "$statefile" ]]; then
    # verify cookie in the first line
    line=`head -n 1 $statefile`
    if [[ $line != $cookie ]]; then
        echo "Incorrectly formatted restoration file. Exiting."
        exit
    fi

    # parse arguments
    for line in `grep '^#' $statefile`; do
        val=`echo $line | cut -d '=' -f2`
        case $line in
            *num*)
                num=$val
                ;;
            *min*)
                min=$val
                ;;
            *max*)
                max=$val
                ;;
            *step*)
                step=$val
                ;;
            *plotfile*)
                plotfile=`echo $line | cut -d '=' -f2`
                ;;
        esac
    done
fi


#
# validate arguments
#
if [[ -z "$num" ]]; then
    echo "invalid num argument"
    exit 1
fi
if [[ -z "$min" ]]; then
    echo "invalid min argument"
    exit 1
fi
if [[ -z "$max" ]]; then
    echo "invalid max argument"
    exit 1
fi
if [[ -z "$step" ]]; then
    echo "invalid step argument"
    exit 1
fi
if [[ -z "$statefile" ]]; then
    statefile="beetle.state"
    echo $cookie >> $statefile
fi


#
# run beetle
#
size=$min

while [[ $size -le $max ]]; do
    ./beetle $size $num | awk -F' ' '{ print $1, $11 }' >> $statefile
    size=`expr $size + $step`
done


#
# create plot
#
if [[ -n $plotfile  ]]; then
    gnuplot -p -e 'set term png; set output "'$plotfile'"; set xlabel "Square size"; set ylabel "Mean beetle lifetime"; plot "'$statefile'"'
fi

#
# output
# don't output lines with metadata (starting with #)
#
cat $statefile | grep -v '^#'


#
# clean up
#
cleanup

